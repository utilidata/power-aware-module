// @generated
// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PowerCalculations {
    /// Required.
    /// Real power (Watts)
    #[prost(float, optional, tag="1")]
    pub real_power_w: ::core::option::Option<f32>,
    /// Required.
    /// Apparent power (Volt*Amps)
    #[prost(float, optional, tag="2")]
    pub apparent_power_va: ::core::option::Option<f32>,
    /// Required.
    /// Reactive power (Volt*Amps reactive)
    #[prost(float, optional, tag="3")]
    pub reactive_power_var: ::core::option::Option<f32>,
    /// Required.
    /// Power factor (unitless)
    #[prost(float, optional, tag="4")]
    pub power_factor: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Provenance {
    /// Required.
    /// UTC timestamp - TODO: document if this
    /// corresponds to the first timestamp, last
    /// timestamp, or something else. Presumably this
    /// comes from metrorec.
    #[prost(message, optional, tag="1")]
    pub utc_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required.
    /// Sequence number from metrorec. TODO: document if this
    /// corresponds to the first timestamp, last
    /// timestamp, or something else.
    #[prost(uint64, optional, tag="2")]
    pub generic_sequence_number: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WaveformCalculations {
    /// Required.
    /// Root mean square for the waveform in question.
    #[prost(float, optional, tag="1")]
    pub rms: ::core::option::Option<f32>,
    /// Required.
    /// DC offset (for sinusoids this is a simple mean).
    #[prost(float, optional, tag="2")]
    pub dc_offset: ::core::option::Option<f32>,
}
/// Waveform and power calculations with provenance.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompositeCalculations {
    /// Required.
    #[prost(message, optional, tag="1")]
    pub provenance: ::core::option::Option<Provenance>,
    /// Required.
    /// Waveform calculations for voltage (Volts)
    #[prost(message, optional, tag="2")]
    pub voltage_waveform_calculations_v: ::core::option::Option<WaveformCalculations>,
    /// Required.
    /// Waveform calculations for current (Amps)
    #[prost(message, optional, tag="3")]
    pub current_waveform_calculations_a: ::core::option::Option<WaveformCalculations>,
    /// Required.
    /// Power calculations requiring both current and voltage.
    #[prost(message, optional, tag="4")]
    pub power_calculations: ::core::option::Option<PowerCalculations>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompositeTwoPhaseCalculations {
    /// Required.
    #[prost(message, optional, tag="1")]
    pub phase_a: ::core::option::Option<CompositeCalculations>,
    /// Required.
    #[prost(message, optional, tag="2")]
    pub phase_b: ::core::option::Option<CompositeCalculations>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fft {
    /// Required.
    #[prost(message, optional, tag="1")]
    pub provenance: ::core::option::Option<Provenance>,
    /// Required.
    /// The magnitude of the fft
    #[prost(float, repeated, tag="2")]
    pub magnitude: ::prost::alloc::vec::Vec<f32>,
    /// Required
    /// The phase
    #[prost(float, repeated, tag="3")]
    pub phase: ::prost::alloc::vec::Vec<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeJoinedCalculationsWrapper {
    /// Required
    /// The name of the stream of origin for the calculations
    #[prost(string, optional, tag="1")]
    pub calculation_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required
    /// The calculations.
    #[prost(oneof="composite_joined_calculations_wrapper::DataProduct", tags="2, 3")]
    pub data_product: ::core::option::Option<composite_joined_calculations_wrapper::DataProduct>,
}
/// Nested message and enum types in `CompositeJoinedCalculationsWrapper`.
pub mod composite_joined_calculations_wrapper {
    /// Required
    /// The calculations.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataProduct {
        #[prost(message, tag="2")]
        Calculations(super::CompositeTwoPhaseCalculations),
        #[prost(message, tag="3")]
        Fft(super::Fft),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeJoinedCalculations {
    #[prost(message, repeated, tag="1")]
    pub calculations: ::prost::alloc::vec::Vec<CompositeJoinedCalculationsWrapper>,
}
// @@protoc_insertion_point(module)